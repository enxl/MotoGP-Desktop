CSS
---
Si no podemos usar class ni id en css:
Usar pseudoclses como first-of-type.

text-decoration-line: Gestiona texto subrayado, tachado...

Dar comportamiento "flow" al display:
Utilizar el módulo CSS Flexible Box Layout
    - Contenedor: Permite controlar las cajas que forman los  elementos.
    - display-flex: Aplicar a los contenedores (e.g. header).
    - Referencia (leer): CSS-Tricks: Flexbox Layout Gride.
    - Dentro de header, también podemos "flexear" el nav para que se adapten los enlaces.

Hoja layout.css debe ser exclusiva para el posicionamiento de los elementos.

Media Queries: Permite cambiar comportamiento del posicionamiento de los elementos (van en layout.css).
    - Dentro del cuerpo van los selectores a los que se le apica la media query. Ejemplo:

    @media... {
        header {
            flex-direction: column;
        }
    }

Resumen flex:
    - flex-direction: Establece dirección en la que se establecen los elementos.
    - flex-wrap: Evita que los elementos se salgan del contenedor

XML Schema 
----------
Generar código: La información se sace mediante expresiones XPath a través del árbol DOM.

JS
--
Devolver el nombre tal cual.
Devolver la lista con el resto de atributos ya formateada en HTML.
Coordenadas: Devuelve document.write("<p>...<p>") en el JS.

Instancias: <head>
                <script src"..."/>
            </head>
            <body>
                <script var ciudad = new Ciudad(...)>
                A partir de aquí se puede usar la ciudad.
            </body>

Validar HTML con JS integrado: Clic en la etiqueta xml, copiar el elemento, ir al validador y pegarlo.

Cartas: Dentro del bloque main:
<main>
    <h2>Juego De Memoria</h2>
        <article>
            <h3>Memory Card</h3>
            <img src="..." alt="..."/>
        </article>
        (...)
</main>

Grid:
display: grid
grid-template-columns: repeat(4, 1fr) (fr es la fracción) => 1fr, 1fr, 1fr, 1fr
glid-template-rows: repeat(4, 1fr)
grid-gap 2em?

Eventos:
Estados de las tarjetas:
Añadir atributo data-state="flip" al article.
Mediante atributo onClick="mem.flipCard(this) en el article, evento de ratón.

Cronómetro: Utilizar objeto Temporal.
Utilizar bloques try-catch para usar temporal.
Si no esta disponible, utilizar objeto Date.
Tomar referencia de tiempo al iniciar.
Otra referencia en actualizar.
Lo transcurrido se guarda en el atributo tiempo.
Una vez cada décima de segundo.
Date -> Usar this.corriendo= setInterval(..., t)